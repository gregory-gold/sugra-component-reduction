{
	"cell_id": 18238172922404832629,
	"cells": [
		{
			"cell_id": 13521187995905660898,
			"cell_origin": "client",
			"cell_type": "input",
			"source": "from latex_macros import *\nfrom props import *\nfrom subs import *\nfrom py.SUGRA5DN1 import *"
		},
		{
			"cell_id": 7140258235550293453,
			"cell_origin": "client",
			"cell_type": "input",
			"source": "# Method to remove redundant \\epsilon tensors.\ndef eliminate_epsilon(exp):\n    substitute(exp, epsilon_to_kronecker)\n    eliminate_kronecker(exp)\n    return(exp)"
		},
		{
			"cell_id": 11657133174110981878,
			"cell_origin": "client",
			"cell_type": "input",
			"source": "## Methods used to ensure simplification of dummy objects \\Lambda and \\Omega and notation-specific objects \\Sigma and \\Gamma. ##\ndef canonicalise_Lambda(exp):\n    rewrite_indices(exp, $\\Lambda^{i}_{\\ah}^{A}$, $\\e^{\\ah \\bh}$)\n    rewrite_indices(exp, $\\Lambda^{i}_{\\ah}^{A}$, $\\e_{i j}$)\n    return(exp)\n\ndef canonicalise_Omega(exp):\n    rewrite_indices(exp, $\\Omega_{\\5a \\5b}^{H}$, $\\eta^{\\5a \\5b}$)\n    return(exp)\n\ndef canonicalise_Sigma(exp):\n    rewrite_indices(exp, $\\Sigma_{\\5a \\5b}_{\\ah \\bh} $, $\\eta^{\\5a \\5b}$)\n    rewrite_indices(exp, $\\Sigma_{\\5a \\5b}_{\\ah \\bh} $, $\\e^{\\ah \\bh}$)\n    return(exp)\n\ndef canonicalise_Gamma(exp):\n    rewrite_indices(exp, $\\Gamma^{\\5a}_{\\ah \\bh}$, $\\eta_{\\5a \\5b}$)\n    rewrite_indices(exp, $\\Gamma^{\\5a}_{\\ah \\bh}$, $\\e^{\\ah \\bh}$)\n    return(exp)\n\ndef canonicalise_Gamma_reverse(exp):\n    rewrite_indices(exp, $\\Gamma^{\\5a}^{\\ah \\bh}$, $\\e_{\\ah \\bh}$)\n    return(exp)\n\ndef canonicalise_eLevi(exp):\n    rewrite_indices(exp, $\\eLevi^{e1 e2 e3 e4 e5}$, $\\eta_{e1 e2}$)\n    return(exp)\n\ndef canonicalise_eLevi_lower(exp):\n    rewrite_indices(exp, $\\eLevi_{e1 e2 e3 e4 e5}$, $\\eta^{e1 e2}$)\n    return(exp)\n\ndef canonicalise_fields(exp):\n    rewrite_indices(exp, $W_{\\5a \\5b}$, $\\eta^{e1 e2}$)\n    rewrite_indices(exp, $\\cHt_{\\5a \\5b}$, $\\eta^{e1 e2}$)\n    rewrite_indices(exp, $\\cH_{\\5a \\5b \\5c}$, $\\eta^{e1 e2}$)\n    rewrite_indices(exp, $\\nu_{\\5a}$, $\\eta^{e1 e2}$)\n    rewrite_indices(exp, $F_{\\5a \\5b}$, $\\eta^{e1 e2}$)\n    rewrite_indices(exp, $\\wX_{\\5a \\5b}^{i j}$, $\\eta^{e1 e2}$)\n    rewrite_indices(exp, $\\wW_{\\5a \\5b \\5c \\5d}$, $\\eta^{e1 e2}$)\n    rewrite_indices(exp, $C_{\\5a \\5b \\5c \\5d}$, $\\eta^{e1 e2}$)\n    rewrite_indices(exp, $R_{\\5a \\5b \\5c \\5d}$, $\\eta^{e1 e2}$)\n    rewrite_indices(exp, $G^{i j}$, $\\e_{k l}$)\n    return(exp)"
		},
		{
			"cell_id": 6307307016111843972,
			"cell_origin": "client",
			"cell_type": "input",
			"source": "import re\ndef is_object_a_derivative(object):\n\tis_der = False\n\tfor arg in object.args():\n\t\tis_der = True\n\t\tbreak\n\treturn is_der\n\ndef sort(ex):\n\t\n\tfor term in ex.top().terms():\n\t\t\n\t\t# Create convenient list of useful charteristics of each object in term. These are [<entire_object>, <number_of_derivatives>, <fermionic>, <object/nested_object name>, <index1>, ..., <indexN>]\n\t\tterm_sort = []\n\t\tterm_exps = []\n\t\tif term.name == '\\\\prod': # Only sort if term is a product of objects.\n\t\t\tfor object in term.children():\n\t\t\t\tfermionic = False\n\t\t\t\tfinal_object = object\n\t\t\t\tder_num = 0\n\t\t\t\tfor child in object.children():\n\t\t\t\t\tfermionic = not fermionic if re.sub('\\d\\d|\\d','#', child.name) in anti_commute else fermionic\n\n\t\t\t\tif is_object_a_derivative(object):\n\t\t\t\t\tinside = False\n\t\t\t\t\tcurrent_object = object\n\t\t\t\t\tder_num = 0\n\t\t\t\t\twhile not inside:\n\t\t\t\t\t\tder_num += 1\n\t\t\t\t\t\tinside = True\n\t\t\t\t\t\tfor arg in current_object.args():\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tfor child in arg.children():\n\t\t\t\t\t\t\t\tfermionic = not fermionic if re.sub('\\d\\d|\\d','#', child.name) in anti_commute else fermionic\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif not is_object_a_derivative(arg):\n\t\t\t\t\t\t\t\tfinal_object = arg\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tinside = False\n\t\t\t\t\t\t\t\tcurrent_object = arg\n\t\t\t\tterm_sort.append([der_num, fermionic, final_object.name] + [index.name for index in final_object.indices()])\n\t\t\t\tterm_exps.append(object.ex())\n\t\t\t\t\n\t\t\t#print(term_sort)\t\t\n\t\t\t# Sort List and check anticommutation if switch field order\n\t\t\tsorting = True\n\t\t\tnew_term = Ex(str(term.multiplier))\n\t\t\tdebug = 0\n\t\t\twhile sorting:\n\t\t\t\tdebug += 1\n\t\t\t\tsorting = False\n\n\t\t\t\tfor i in range(1, len(term_sort)):\n\t\t\t\t\tobjectL = term_sort[i - 1]\n\t\t\t\t\tobjectR = term_sort[i]\n\t\t\t\t# Swap Conditions, in order of priority, (letters are equal priority)\n\t\t\t\t#1: higher derivative number goes right always\n\t\t\t\t#2: if equal derivatives (including zero)\n\t\t\t\t#2a: switch if sort_order dictates\n\t\t\t\t#2b: if sort_order dictates just one, move that one left\n\t\t\t\t#2c: if sort_order dictates neither\n\t\t\t\t#2cA: sort lexographic by field name\n\t\t\t\t#2cB: if same field, sort lexographic by field+index list\n\t\t\t\n\t\t\t\t\t### This is poorly optimized. We should only check next condition if previous one doesn't fire.\n\t\t\t\t\tswap_condition_one = (objectL[0] > objectR[0])\n\t\t\t\t\tswap_condition_two_a = (objectL[0] == objectR[0]) and ((objectR[2] in sort_order_map) and (objectL[2] in sort_order_map)) and (sort_order_map[objectL[2]] > sort_order_map[objectR[2]])\n\t\t\t\t\tswap_condition_two_b = (objectL[0] == objectR[0]) and ((objectR[2] in sort_order_map) and (objectL[2] not in sort_order_map))\n\t\t\t\t\tswap_condition_two_cA = (objectL[0] == objectR[0]) and (objectR[2] not in sort_order_map) and (objectL[2] not in sort_order_map) and objectL[2] > objectR[2]\n\t\t\t\t\tswap_condition_two_cB = (objectL[0] == objectR[0]) and (objectL[2] == objectR[2]) and (objectL[2:] > objectR[2:])\n\t\t\t\t\t\n\t\t\t\t\tif swap_condition_one or swap_condition_two_a or swap_condition_two_b or swap_condition_two_cA or swap_condition_two_cB:\t\t\t\t\n\t\t\t\t\t\t#print('swapping objects ' + str(i) + ' and ' + str(i-1))\n\t\t\t\t\t\tsorting = True\n\t\t\t\t\t\tterm_sort[i] = objectL\n\t\t\t\t\t\tterm_sort[i - 1] = objectR\n\t\t\t\t\t\tnext(x for j, x in enumerate(term.children()) if j==i).replace(term_exps[i-1])\n\t\t\t\t\t\tnext(x for j, x in enumerate(term.children()) if j==i-1).replace(term_exps[i])\n\t\t\t\t\t\tplaceholder = term_exps[i]\n\t\t\t\t\t\tterm_exps[i] = term_exps[i - 1]\n\t\t\t\t\t\tterm_exps[i - 1] = placeholder\n\t\t\t\t\t\tif objectL[1] and objectR[1]:\n\t\t\t\t\t\t\tterm.replace(term.ex() * Ex(-1))\n\t\t\t\t\t\t#print(term_sort)\n\t\n\t\t\t# Convert sorted list to expression (signs and multipler already handled)\n\t\t\t#for object in term_sort:\n\t\t\t#\tnew_term *= Ex(object[0])\n\n\t\t\t#term.replace(new_term)\n\t\n\treturn ex"
		},
		{
			"cell_id": 17537999774382983796,
			"cell_origin": "client",
			"cell_type": "input",
			"source": "def count_terms(exp):\n    total_terms = 0\n    for term in exp.top().terms():\n        total_terms += 1\n    return(total_terms)\n\n# Simple class to contain clever simplify methods\nclass CleverSimplify:\n\n    def __init__(self, exp):\n        self.exp = exp\n        self.post_processing = False\n        self.terms_per_iteration = []\n        self.logical_structures = []\n        self.timer = StopWatch()\n\n    def display_details(self):\n        print(self.terms_per_iteration)\n        print(\"\\n\")\n        for struct in self.logical_structures:\n            print(struct)\n            print(\"\\n\")\n            \n    def manual_post_processing(self):\n        collect_factors(self.exp)\n        substitute(self.exp, reduce_G)\n        canonicalise_Gamma(self.exp)\n        canonicalise_Sigma(self.exp)\n        canonicalise_eLevi(self.exp)\n        substitute(self.exp,contract_fields,repeat=True)\n        canonicalise(self.exp)\n        substitute(self.exp, contract_metric, repeat=True)\n        eliminate_kronecker(self.exp,repeat=True)\n        substitute(self.exp, gamma_properties)\n        rename_dummies(self.exp)\n        sort(self.exp)\n        canonicalise(self.exp)\n        canonicalise_Gamma(self.exp)\n        canonicalise_Sigma(self.exp)\n        #eliminate_metric(self.exp,repeat=True,redundant=True)\n        substitute(self.exp, canonicalise_vector)\n        substitute(self.exp, contract_metric,repeat=True)\n        eliminate_kronecker(self.exp)\n        rename_dummies(self.exp)\n        sort(self.exp)\n        canonicalise(self.exp)\n        return(self.exp)\n    \n    # This method finds occurances of objects in expression and optionally the children of objects. If nested_objects is defined, it will find objects nested within a parent (like inside a derivative for example).\n    def check_entire_expression_for_object(self, logic_struct, object, nested_objects = [], add_parent_object = False):\n        for occurance in self.exp[object]:\n            if nested_objects:\n                for child in occurance.children():\n                    for nested_object in nested_objects:\n                        if str(child.name) == nested_object:\n                            logic_struct[nested_object] +=1\n            if not nested_objects or add_parent_object:\n                    logic_struct[object] +=1\n        return(logic_struct)\n\n    # This method goes term by term to find implicit simplifications that are index-dependent. Checking for \\vW is the oddball here so for now it's just optionally added at the end.\n    def check_terms(self, logic_struct, contraction_combos, check_for_factors = False, check_for_eLevi = False):\n        total_terms = 0\n        for term in self.exp.top().terms():\n            total_terms += 1\n            for combo in contraction_combos.keys():\n                index_struct = {}\n                for object in contraction_combos[combo]:\n                    for occurance in term[object]:\n                        for ind in occurance.free_indices():\n                            if str(ind) in index_struct:\n                                index_struct[str(ind)] += 1\n                            elif str(ind) not in index_struct:\n                                index_struct[str(ind)] = 1\n                    \n                if len([i for i in list(index_struct.values()) if i > 1])  > 0:\n                    logic_struct[combo] += 1\n            \n            if check_for_factors:\n                vW_num = 0\n                nested = False\n                index_next = False\n                for n in term.ex():\n                \n                    if n.name == \"\\\\vD\" or n.name == \"\\\\vDh\" or n.name == \"\\\\D\" or n.name == \"K\" or n.name == \"S\" or n.name == \"M\" or n.name == \"J\" or n.name == \"\\\\mD\":\n                        nested = True\n                        index_next = True\n                    elif n.name == \"\\\\cD\":\n                        nested = True\n                    elif index_next:\n                        index_next = False\n                    elif n.name == \"\\\\vW\" and not nested:\n                        vW_num += 1\n                    elif n.name != \"\\prod\":\n                        nested = False\n    \n                if vW_num > 1:\n                    logic_struct[\"collect_vW_terms\"] += 1\n\n            if check_for_eLevi:\n                eLevi_num = 0\n                for n in term.ex():\n                \n                    if n.name == \"\\\\eLevi\":\n                        eLevi_num += 1\n    \n                if eLevi_num > 1:\n                    logic_struct[\"eLevi_contract_terms\"] += 1\n\n        self.terms_per_iteration.append(total_terms)\n        return(logic_struct)\n        \n    def expression_check(self, consistency, apply_symmetrize):\n        logic_struct = {\"\\\\D\":0, \"K\":0, \"S\":0, \"\\\\vDh\":0, \"\\\\mD\":0, \"\\\\cD\":0, \"M\":0, \"J\":0, \"\\\\ILambda\":0, \"\\\\IOmega\":0, \"\\\\IAOmega\":0, \"\\\\Symmetrize\":0, \"\\\\ASymmetrize\":0, \"\\\\sum\":0, \"\\\\prod\":0, \"\\\\pow\":0, \"epsilon_contracts\":0, \"identity_contracts\":0, \"collect_vW_terms\":0, \"collect_G_terms\":0, \"eLevi_contract_terms\":0}\n        logic_struct = self.check_entire_expression_for_object(logic_struct, \"\\\\D\", [\"\\\\sum\",\"\\\\prod\", \"\\\\pow\", \"\\\\vDh\"], True)\n        logic_struct = self.check_entire_expression_for_object(logic_struct, \"\\\\vDh\", [\"\\\\sum\",\"\\\\prod\", \"\\\\pow\"])\n        if consistency:\n            logic_struct = self.check_entire_expression_for_object(logic_struct, \"\\\\mD\", [\"\\\\sum\",\"\\\\prod\", \"\\\\pow\"])\n            logic_struct = self.check_entire_expression_for_object(logic_struct, \"K\", [\"\\\\sum\",\"\\\\prod\", \"\\\\pow\", \"\\\\vDh\", \"\\\\mD\"], True)\n            logic_struct = self.check_entire_expression_for_object(logic_struct, \"S\", [\"\\\\sum\",\"\\\\prod\", \"\\\\pow\", \"\\\\vDh\"], True)\n            logic_struct = self.check_entire_expression_for_object(logic_struct, \"\\\\cD\", [\"\\\\sum\",\"\\\\prod\", \"\\\\pow\", \"\\\\vDh\"], True)\n            logic_struct = self.check_entire_expression_for_object(logic_struct, \"M\", [\"\\\\sum\",\"\\\\prod\", \"\\\\pow\", \"\\\\vDh\"], True)\n            logic_struct = self.check_entire_expression_for_object(logic_struct, \"J\", [\"\\\\sum\",\"\\\\prod\", \"\\\\pow\", \"\\\\vDh\"], True)\n        logic_struct = self.check_entire_expression_for_object(logic_struct, \"\\\\prod\",[\"\\\\sum\"])\n        logic_struct = self.check_entire_expression_for_object(logic_struct, \"\\\\ILambda\")\n        logic_struct = self.check_entire_expression_for_object(logic_struct, \"\\\\IOmega\")\n        logic_struct = self.check_entire_expression_for_object(logic_struct, \"\\\\IAOmega\")\n        if apply_symmetrize:\n            logic_struct = self.check_entire_expression_for_object(logic_struct, \"\\\\Symmetrize\")\n            logic_struct = self.check_entire_expression_for_object(logic_struct, \"\\\\ASymmetrize\")\n    \n        # Loop through all terms for index-dependent contractions.\n        check_for_factors = False\n        check_for_eLevi = True\n        contraction_combos = {\"epsilon_contracts\": [\"\\\\e\"], \"identity_contracts\": [\"\\\\Gamma\", \"\\\\Sigma\"]}\n        logic_struct = self.check_terms(logic_struct, contraction_combos, check_for_factors, check_for_eLevi)\n\n        return(logic_struct)\n    \n    \n    ### Contains all of the expression manipulations depndent on results of expression_check() ###\n    def simplify(self, struct):\n        if struct[\"\\\\prod\"] or  struct[\"\\\\pow\"] > 0:\n            unwrap(self.exp)\n            product_rule(self.exp)\n            distribute(self.exp)\n        elif struct[\"\\\\sum\"] > 0:\n            distribute(self.exp)\n        elif struct[\"collect_vW_terms\"] > 0 or struct[\"collect_G_terms\"] > 0:\n            collect_factors(self.exp)\n        elif struct[\"\\\\vDh\"] > 0 or struct[\"\\\\mD\"] > 0:\n            substitute(self.exp, vector_algebra_spinor)\n            substitute(self.exp, generators_vector)\n            substitute(self.exp, generators_weyl)\n            substitute(self.exp, generators_O2)\n        elif struct[\"\\\\D\"] > 0:\n            substitute(self.exp, tower_project_vector)\n            substitute(self.exp, tower_project_weyl)\n            substitute(self.exp, tower_project_O2)\n        elif struct[\"K\"] > 0 or struct[\"S\"] > 0 or struct[\"\\\\cD\"] > 0 or struct[\"M\"] > 0 or struct[\"J\"] > 0:\n            substitute(self.exp, generators_vector)\n            substitute(self.exp, generators_weyl)\n            substitute(self.exp, generators_O2)\n\n        if struct[\"\\\\ILambda\"] > 0:\n            canonicalise_Lambda(self.exp)\n            substitute(self.exp, remove_Lambda)\n            eliminate_kronecker(self.exp)\n\n        if struct[\"\\\\IOmega\"] or struct[\"\\\\IAOmega\"] > 0:\n            canonicalise_Omega(self.exp)\n            substitute(self.exp, remove_Omega)\n            substitute(self.exp, symmetrize_indices)\n            distribute(self.exp)\n            eliminate_kronecker(self.exp)\n        elif struct[\"\\\\Symmetrize\"] > 0 or struct[\"\\\\ASymmetrize\"] > 0:\n            substitute(self.exp, symmetrize_indices)\n            distribute(self.exp)\n            eliminate_kronecker(self.exp)\n\n        if struct[\"epsilon_contracts\"] > 0:\n            eliminate_epsilon(self.exp)\n        \n        if struct[\"eLevi_contract_terms\"] > 0:\n            epsilon_to_delta(self.exp, repeat=True)\n            expand_delta(self.exp)\n            distribute(self.exp)\n            eliminate_kronecker(self.exp)\n            canonicalise_fields(self.exp)\n            substitute(self.exp, contract_metric, repeat=True)\n            eliminate_kronecker(self.exp)\n            substitute(self.exp,contract_fields,repeat=True)\n                    \n        if struct[\"identity_contracts\"] > 0:\n            canonicalise_Gamma(self.exp)\n            canonicalise_Sigma(self.exp)\n            canonicalise_eLevi(self.exp)\n            substitute(self.exp, contract_metric, repeat=True)\n            eliminate_kronecker(self.exp,repeat=True)\n            substitute(self.exp,contract_fields,repeat=True)\n            canonicalise(self.exp)\n            substitute(self.exp, gamma_properties)\n\n        if self.post_processing:\n            collect_factors(self.exp)\n            substitute(self.exp, imaginary_simplify)\n            substitute(self.exp, reduce_G)\n            canonicalise_Gamma(self.exp)\n            canonicalise_Sigma(self.exp)\n            canonicalise_eLevi(self.exp)\n            substitute(self.exp,contract_fields,repeat=True)\n            canonicalise(self.exp)\n            substitute(self.exp, contract_metric, repeat=True)\n            eliminate_kronecker(self.exp,repeat=True)\n            substitute(self.exp, gamma_properties)\n            rename_dummies(self.exp)\n            #sort(self.exp)\n            canonicalise(self.exp)\n            canonicalise_Gamma(self.exp)\n            canonicalise_Sigma(self.exp)\n            substitute(self.exp, canonicalise_vector)\n            substitute(self.exp, contract_metric,repeat=True)\n            eliminate_kronecker(self.exp)\n            substitute(self.exp, remove_zeros)\n            rename_dummies(self.exp)\n            sort(self.exp)\n            canonicalise(self.exp)\n\n\n    def main(self, iterations, consistency = False, apply_symmetrize = True):\n        \n        for i in range(iterations):\n            \n            ### Check Expression ###\n            logic_struct = self.expression_check(consistency, apply_symmetrize)\n            self.logical_structures.append(logic_struct)\n\n            ### Check if Completed and Post Processing Switch ###\n            if len([i for i in list(logic_struct.values()) if i != 0])  == 0:\n                if self.post_processing:\n                    break\n                else:\n                    self.post_processing = True\n            else:\n                self.post_processing = False\n\n            ### Simplify Expression ###\n            self.simplify(logic_struct)\n\n        logic_struct = self.expression_check(consistency, apply_symmetrize)\n        self.logical_structures.append(logic_struct)\n        return(self.exp)"
		},
		{
			"cell_id": 3019198449792338757,
			"cell_origin": "client",
			"cell_type": "input",
			"source": "def update_Gs(term, G_pair, G1_indices, G2_indices, convert_G_to_eps = False):\n\treplaced = 0\n\tfor G in term[\"G\"]:\n\t\tif str(G) in G_pair:\n\t\t\tindices = G.indices()\n\t\t\tif convert_G_to_eps:\n\t\t\t\tG.name = '\\\\e'\n\n\t\t\tif replaced == 0:\n\t\t\t\tnext(indices).name = G1_indices[0]\n\t\t\t\tnext(indices).name = G1_indices[1]\n\t\t\telse:\n\t\t\t\tnext(indices).name = G2_indices[0]\n\t\t\t\tnext(indices).name = G2_indices[1]\n\t\t\treplaced += 1\t\n\ndef G_symmetry_simplify(ex,debug = False):\t\n\n\tfor debugi, term in enumerate(ex.top().terms()):\n\t\tif debug:\n\t\t\tdisplay(term)\n\t\t\tdisplay(debugi)\n\t\t\tdisplay_step = 1;\t\t\n\t\tantisymmetric_spinors1 = [(next(eps.indices()).name, next(next(eps.indices())).name) for eps in term[\"\\\\e\"] if \"h\" in str(eps)]\n\t\tantisymmetric_spinors2 = [(next(next(gam.indices())).name, next(next(next(gam.indices()))).name) for gam in term[\"\\\\Gamma\"]]\n\t\tantisymmetric_spinors = antisymmetric_spinors1 + antisymmetric_spinors2\n\t\tif debug:\n\t\t\tdisplay(antisymmetric_spinors)\n\t\t\tdisplay_step = 2;\n\t\tsymmetric_su2s = []\n\t\t# Clean this up\n\t\tfor combo in antisymmetric_spinors:\t\t\n\t\t\tsu2_combo = []\n\t\t\tfor fermion in term[\"\\\\varphi\"]:\n\t\t\t\tindices = fermion.indices()\n\t\t\t\tsu2_index = next(indices).name\t\n\t\t\t\tspinor_index = next(indices).name\n\t\t\t\tif spinor_index in combo:\n\t\t\t\t\tsu2_combo.append(su2_index)\n\t\t\tfor fermion in term[\"X\"]:\n\t\t\t\tindices = fermion.indices()\n\t\t\t\tsu2_index = next(indices).name\t\n\t\t\t\tspinor_index = next(indices).name\n\t\t\t\tif spinor_index in combo:\n\t\t\t\t\tsu2_combo.append(su2_index)\n\n\t\t\tif len(su2_combo) == 2:\n\t\t\t\tsymmetric_su2s.append(tuple(item for item in su2_combo))\n\t\tif debug:\n\t\t\tdisplay(symmetric_su2s)\n\t\t\tdisplay_step = 3;\n\t\tfor index, symmetric_combo in enumerate(symmetric_su2s):\n\t\t\tnew_combo = []\n\t\t\tfor eps in term[\"\\\\e\"]:\n\t\t\t\tif \"h\" not in str(eps):\n\t\t\t\t\tindices = eps.indices()\n\t\t\t\t\tsu2one = next(indices).name\n\t\t\t\t\tsu2two = next(indices).name\n\t\t\t\t\tif (su2one in symmetric_combo and su2two not in symmetric_combo):\n\t\t\t\t\t\tnew_combo.append(su2two)\n\t\t\t\t\telif (su2two in symmetric_combo and su2one not in symmetric_combo):\n\t\t\t\t\t\tnew_combo.append(su2one)\n\t\t\tif len(new_combo) == 2:\n\t\t\t\tsymmetric_su2s[index] = tuple(item for item in new_combo)\n\t\tif debug:\n\t\t\tdisplay(symmetric_su2s)\n\t\t\tdisplay_step = 4;\n\n\t\tfor symmetric_combo in symmetric_su2s:\n\t\t\tG_pair = []\n\t\t\tsu2_pair = []\n\t\t\tfor G in term[\"G\"]:\n\t\t\t\tif '^' in str(G):\n\t\t\t\t\tindices = G.indices()\n\t\t\t\t\tsu2one = str(next(indices))\n\t\t\t\t\tsu2two = str(next(indices))\n\t\t\t\t\tif (su2one in symmetric_combo and su2two not in symmetric_combo):\n\t\t\t\t\t\tG_pair.append(str(G))\n\t\t\t\t\t\tsu2_pair.append(su2two)\n\t\t\t\t\telif (su2two in symmetric_combo and su2one not in symmetric_combo):\n\t\t\t\t\t\tG_pair.append(str(G))\n\t\t\t\t\t\tsu2_pair.append(su2one)\n\t\t\t# Update term \n\t\t\tif len(G_pair) == 2:\n\t\t\t\tnew_term1 = term.ex()\n\t\t\t\tnew_term2 = term.ex()\n\t\t\t\tupdate_Gs(term, G_pair, su2_pair, symmetric_combo)\n\t\t\t\tupdate_Gs(new_term1, G_pair, (su2_pair[0], symmetric_combo[0]), (symmetric_combo[1], su2_pair[1]), True)\n\t\t\t\tupdate_Gs(new_term2, G_pair, (su2_pair[0], symmetric_combo[1]), (symmetric_combo[0], su2_pair[1]), True)\n\t\t\t\tGsquared :=  (1/2) G**(2).\n\t\t\t\tterm += new_term1 * Gsquared + new_term2 * Gsquared\n\t\t\t\tbreak\n\t\n\t\t\telif len(G_pair) > 2:\n\t\t\t\traise Exception(\"There is a problem in G_pair: \" + str(G_pair))\n\t\t\t\n\treturn ex"
		},
		{
			"cell_id": 15323645833515089945,
			"cell_origin": "client",
			"cell_type": "input",
			"source": ""
		}
	],
	"description": "Cadabra JSON notebook format",
	"version": 1.0
}
