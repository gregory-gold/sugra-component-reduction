{
	"cell_id": 18238172922404832629,
	"cells": [
		{
			"cell_id": 13521187995905660898,
			"cell_origin": "client",
			"cell_type": "input",
			"source": "# For manual use. This is exlcuded from import.\nfrom latex_macros4D import *\nfrom properties4D import *\nfrom substitutions4D import * "
		},
		{
			"cell_id": 17648920809680512406,
			"cell_origin": "client",
			"cell_type": "input",
			"source": "import sys\ncurrent_path = str(sys.path[0])\nrepo_name  = 'sugra-component-reduction'\npy_path = current_path.split(repo_name)[0] + repo_name + '/py/'\nsys.path.append(py_path)\nfrom shared import *"
		},
		{
			"cell_id": 11691567571435248728,
			"cell_origin": "client",
			"cell_type": "input",
			"source": "sorter = Sort(sort_order, anti_commute)\ndef sort(exp):\n\tsorter.sort(exp)\n\treturn(exp)\n\nexpression_path = current_path.split(repo_name)[0] + repo_name + '/4DN2/saved_expressions/'\nsaver = ExpressionSaver(expression_path)"
		},
		{
			"cell_id": 7176012223604208792,
			"cell_origin": "client",
			"cell_type": "input",
			"source": "cleanup = CleanUp('\\\\Gamma', [sub, super])\ndef clean_up_spinor(exp, dummy_object = '\\\\vD'):\n\t{Z, Z#}::Indices(dummTemp, position=independent)\n\tsubstitute(exp, Ex(dummy_object + '_{\\\\A}{Q??} -> ' + dummy_object + '_{\\\\A Z}{Q??}'))\n\tcleanup.contract_dummy_auto(exp, dummy_object)\n\tcanonicalise(exp)\n\tcleanup.contract_epsilon_auto(exp)\t\n\teliminate_metric(exp, repeat=True)\n\trename_dummies(exp)\n\treturn exp\n\ndef clean_up_vector(exp):\n\t#substitute(exp, contract_fields_vector_arbitrary, repeat=True)\n\tcleanup.contract_epsilon_auto(exp)\n\teliminate_metric(exp, repeat=True)\n\trename_dummies(exp)\n\treturn exp"
		},
		{
			"cell_id": 4057025789550968640,
			"cell_origin": "client",
			"cell_type": "input",
			"source": "# Method to remove excess \\epsilon tensors.\r\ndef eliminate_epsilon(exp):\n    substitute(exp, epsilon_to_kronecker)\n    eliminate_kronecker(exp)\n    return(exp)\n\n# Methods used to ensure \\Lambda and \\Gamma can be simplified\r\ndef canonicalise_Lambda(exp):\r\n\trewrite_indices(exp, $\\Lambda^{\\a}_{i}^{A}$, $\\e_{\\a \\b}$)\r\n\trewrite_indices(exp, $\\Lambda^{\\a}_{i}^{A}$, $\\e^{i j}$)\r\n\trewrite_indices(exp, $\\Lambda^{\\ad}_{i}^{A}$, $\\e_{\\ad \\bd}$)\r\n\trewrite_indices(exp, $\\Lambda^{\\ad}_{i}^{A}$, $\\e^{i j}$)\r\n\tsort_product(exp)\r\n\tcanonicalise(exp)\r\n\treturn(exp)\r\n\r\ndef canonicalise_Gamma(exp):\r\n\trewrite_indices(exp, $\\Gamma_{a b}^{\\A}$, $\\eta^{a b}$)\n\trewrite_indices(exp, $\\Gamma^{\\A}_{a b}$, $\\eta^{a b}$)\n\trewrite_indices(exp, $\\Gamma_{i j}^{\\i}$, $\\e^{i j}$)\n\trewrite_indices(exp, $\\Gamma^{\\i}_{i j}$, $\\e^{i j}$)\r\n\treturn(exp)\n\ndef canonicalise_sigma(exp):\n\trewrite_indices(exp, $\\s_{c d}^{\\ad \\bd}$, $\\e_{\\ad \\bd}$)\n\trewrite_indices(exp, $\\s^{c d}^{\\ad \\bd}$, $\\e_{\\ad \\bd}$)\r\n\treturn(exp)"
		},
		{
			"cell_id": 5461215191933705412,
			"cell_origin": "client",
			"cell_type": "input",
			"source": "def count_terms(exp):\n    total_terms = 0\n    for term in exp.top().terms():\n        total_terms += 1\n    return(total_terms)\n\n# Simple class to contain clever simplify methods\nclass CleverSimplify:\n\n    def __init__(self, exp):\n        self.exp = exp\n        self.post_processing = False\n        self.terms_per_iteration = []\n        self.logical_structures = []\n        self.timer = StopWatch()\n\n    def display_details(self):\n        print(self.terms_per_iteration)\n        print(\"\\n\")\n        for struct in self.logical_structures:\n            print(struct)\n            print(\"\\n\")\n    \n    # This method finds occurances of objects in expression and optionally the children of objects. If nested_objects is defined, it will find objects nested within a parent (like inside a derivative for example).\n    def check_entire_expression_for_object(self, logic_struct, object, nested_objects = [], add_parent_object = False):\n        for occurance in self.exp[object]:\n            if nested_objects:\n                for child in occurance.children():\n                    for nested_object in nested_objects:\n                        if str(child.name) == nested_object:\n                            logic_struct[nested_object] +=1\n            if not nested_objects or add_parent_object:\n                    logic_struct[object] +=1\n        return(logic_struct)\n\n    # This method goes term by term to find implicit simplifications that are index-dependent. Checking for \\vW is the oddball here so for now it's just optionally added at the end.\n    def check_terms(self, logic_struct, contraction_combos, check_for_factors = False, check_for_eLevi = False):\n        total_terms = 0\n        for term in self.exp.top().terms():\n            total_terms += 1\n            for combo in contraction_combos.keys():\n                index_struct = {}\n                for object in contraction_combos[combo]:\n                    for occurance in term[object]:\t\t\t\n                        for ind in occurance.free_indices():\n                            if str(ind) in index_struct:\n                                index_struct[str(ind)] += 1\n                            elif str(ind) not in index_struct:\n                                index_struct[str(ind)] = 1\n\n                if len([i for i in list(index_struct.values()) if i > 1])  > 0:\n                    logic_struct[combo] += 1\n            \n            if check_for_factors:\n                vW_num = 0\n                nested = False\n                index_next = False\n                for n in term.ex():\n                \n                    if n.name == \"\\\\vD\" or n.name == \"\\\\vDh\" or n.name == \"\\\\D\" or n.name == \"K\" or n.name == \"S\" or n.name == \"M\" or n.name == \"J\" or n.name == \"\\\\mD\":\n                        nested = True\n                        index_next = True\n                    elif n.name == \"\\\\cD\":\n                        nested = True\n                    elif index_next:\n                        index_next = False\n                    elif n.name == \"\\\\vW\" and not nested:\n                        vW_num += 1\n                    elif n.name != \"\\prod\":\n                        nested = False\n    \n                if vW_num > 1:\n                    logic_struct[\"collect_vW_terms\"] += 1\n\n            if check_for_eLevi:\n                eLevi_num = 0\n                for n in term.ex():\n                \n                    if n.name == \"\\\\eLevi\":\n                        eLevi_num += 1\n    \n                if eLevi_num > 1:\n                    logic_struct[\"eLevi_contract_terms\"] += 1\n\n        self.terms_per_iteration.append(total_terms)\n        return(logic_struct)\n     \n    def expression_check(self, consistency, apply_symmetrize):\n        logic_struct = {\"\\\\D\":0, \"\\\\Db\":0, \"\\\\vD\":0, \"Y\":0, \"\\\\K\":0, \"S\":0, \"Sb\":0,  \"D\":0, \"M\":0, \"Mb\":0, \"\\\\J\":0, \"\\\\ILambda\":0, \"\\\\IGamma\":0, \"\\\\sum\":0, \"\\\\prod\":0, \"\\\\pow\":0, \"epsilon_contracts\":0, \"identity_contracts\":0}\n        logic_struct = self.check_entire_expression_for_object(logic_struct, \"\\\\D\", [\"\\\\sum\",\"\\\\prod\", \"\\\\pow\", \"\\\\vD\"], True)\n        logic_struct = self.check_entire_expression_for_object(logic_struct, \"\\\\Db\", [\"\\\\sum\",\"\\\\prod\", \"\\\\pow\", \"\\\\vD\"], True)\n        logic_struct = self.check_entire_expression_for_object(logic_struct, \"\\\\vD\", [\"\\\\sum\",\"\\\\prod\", \"\\\\pow\"])\n        logic_struct = self.check_entire_expression_for_object(logic_struct, \"\\\\mD\", [\"\\\\sum\",\"\\\\prod\", \"\\\\pow\"])\n        logic_struct = self.check_entire_expression_for_object(logic_struct, \"\\\\JD\", [\"\\\\sum\",\"\\\\prod\", \"\\\\pow\"])\n        logic_struct = self.check_entire_expression_for_object(logic_struct, \"\\\\pD\", [\"\\\\sum\",\"\\\\prod\", \"\\\\pow\"])\n        if consistency:\n            logic_struct = self.check_entire_expression_for_object(logic_struct, \"\\\\K\", [\"\\\\sum\",\"\\\\prod\", \"\\\\pow\", \"\\\\vD\"], True)\n            logic_struct = self.check_entire_expression_for_object(logic_struct, \"Y\", [\"\\\\sum\",\"\\\\prod\", \"\\\\pow\", \"\\\\vD\"], True)\n            logic_struct = self.check_entire_expression_for_object(logic_struct, \"S\", [\"\\\\sum\",\"\\\\prod\", \"\\\\pow\", \"\\\\vD\"], True)\n            logic_struct = self.check_entire_expression_for_object(logic_struct, \"Sb\", [\"\\\\sum\",\"\\\\prod\", \"\\\\pow\", \"\\\\vD\"], True)\n            logic_struct = self.check_entire_expression_for_object(logic_struct, \"D\", [\"\\\\sum\",\"\\\\prod\", \"\\\\pow\", \"\\\\vD\"], True)\n            logic_struct = self.check_entire_expression_for_object(logic_struct, \"M\", [\"\\\\sum\",\"\\\\prod\", \"\\\\pow\", \"\\\\vD\"], True)\n            logic_struct = self.check_entire_expression_for_object(logic_struct, \"Mb\", [\"\\\\sum\",\"\\\\prod\", \"\\\\pow\", \"\\\\vD\"], True)\n            logic_struct = self.check_entire_expression_for_object(logic_struct, \"\\\\J\", [\"\\\\sum\",\"\\\\prod\", \"\\\\pow\", \"\\\\vD\"], True)\n        logic_struct = self.check_entire_expression_for_object(logic_struct, \"\\\\prod\",[\"\\\\sum\"])\n        logic_struct = self.check_entire_expression_for_object(logic_struct, \"\\\\ILambda\")\n        logic_struct = self.check_entire_expression_for_object(logic_struct, \"\\\\IGamma\")\n    \n        # Loop through all terms for index-dependent contractions.\n        check_for_factors = False\n        check_for_eLevi = False\n        contraction_combos = {\"epsilon_contracts\": [\"\\\\e\"], \"identity_contracts\":[\"\\\\s\", \"\\\\sb\"]}\n        logic_struct = self.check_terms(logic_struct, contraction_combos, check_for_factors, check_for_eLevi)\n\n        return(logic_struct)\n\n### Contains all of the expression manipulations depndent on results of expression_check() ###\n    def simplify(self, struct):\n        if struct[\"\\\\prod\"] or  struct[\"\\\\pow\"] > 0:\n            unwrap(self.exp)\n            product_rule(self.exp)\n            distribute(self.exp)\n        elif struct[\"\\\\sum\"] > 0:\n            distribute(self.exp)\n        elif struct[\"\\\\vD\"] > 0:\n            substitute(self.exp, vector_algebra)\n            substitute(self.exp, generators_vector)\n            substitute(self.exp, generators_deformed_vector)\n            substitute(self.exp, generators_tensor)\n            substitute(self.exp, generators_hyper)\n            substitute(self.exp, generators_weyl)\n            #substitute(self.exp, generators_weyl)\n        elif struct[\"\\\\D\"] > 0 or struct[\"\\\\Db\"] > 0:\n            substitute(self.exp, tower_project_vector)\n            substitute(self.exp, tower_project_deformed_vector)\n            substitute(self.exp, tower_project_weyl)\n            substitute(self.exp, tower_project_tensor)\n            substitute(self.exp, tower_project_hyper)\n            substitute(self.exp, chain_rule_deformed)\n        elif struct[\"\\\\K\"] > 0 or struct[\"S\"] > 0 or struct[\"Sb\"] > 0 or struct[\"D\"] > 0 or struct[\"M\"] > 0 or struct[\"Mb\"] > 0 or struct[\"\\\\J\"] > 0 or struct[\"Y\"] > 0:\n            substitute(self.exp, generators_vector)\n            substitute(self.exp, generators_deformed_vector)\n            substitute(self.exp, generators_tensor)\n            substitute(self.exp, generators_hyper)\n            substitute(self.exp, generators_weyl)\n\n        if struct[\"\\\\ILambda\"] > 0:\n            substitute(self.exp, remove_lambda)\n            eliminate_kronecker(self.exp)\n\n        if struct[\"\\\\IGamma\"]:\n            substitute(self.exp, remove_gamma)\n            distribute(self.exp)\n            eliminate_kronecker(self.exp)\n\n        if struct[\"identity_contracts\"] > 0:\n            eliminate_epsilon(self.exp)\n            substitute(self.exp, contract_metric, repeat=True)\n            eliminate_kronecker(self.exp,repeat=True)\n            canonicalise(self.exp)\n            substitute(self.exp, sigma_properties)\n        elif struct[\"epsilon_contracts\"] > 0:\n            eliminate_epsilon(self.exp)\n\n        if self.post_processing:\n            collect_factors(self.exp)\n            substitute(self.exp, imaginary_simplify)\n            eliminate_epsilon(self.exp)\n            substitute(self.exp, contract_metric, repeat=True)\n            eliminate_kronecker(self.exp,repeat=True)\n            canonicalise(self.exp)\n            substitute(self.exp, sigma_properties)\n            canonicalise(self.exp)\n            eliminate_kronecker(self.exp,repeat=True)\n            rename_dummies(self.exp)\n            sort(self.exp)\n            canonicalise(self.exp)\n            substitute(self.exp, canonicalise_vector)\n            substitute(self.exp, contract_metric,repeat=True)\n            eliminate_kronecker(self.exp)\n            rename_dummies(self.exp)\n            sort(self.exp)\n            canonicalise(self.exp)\n\n    def main(self, iterations, consistency = False, apply_symmetrize = True):\n        \n        for i in range(iterations):\n            \n            ### Check Expression ###\n            logic_struct = self.expression_check(consistency, apply_symmetrize)\n            self.logical_structures.append(logic_struct)\n\n            ### Check if Completed and Post Processing Switch ###\n            if len([i for i in list(logic_struct.values()) if i != 0])  == 0:\n                if self.post_processing:\n                    break\n                else:\n                    self.post_processing = True\n            else:\n                self.post_processing = False\n\n            ### Simplify Expression ###\n            self.simplify(logic_struct)\n\n        logic_struct = self.expression_check(consistency, apply_symmetrize)\n        self.logical_structures.append(logic_struct)\n        return(self.exp)"
		},
		{
			"cell_id": 10495655078159568319,
			"cell_origin": "client",
			"cell_type": "input",
			"source": ""
		}
	],
	"description": "Cadabra JSON notebook format",
	"version": 1.0
}
